function varargout = updateintensity( this, sensor, varargin )

Z = this.Z; % get the observation set

Zk_len = length(Z.Z);
P_D = this.probdetection;
% lambda_c = sensor.clutter.getlambda;
meas.P_D = this.probdetection;
meas.clutterpdf = sensor.getclpdf(Z.Z);%1/(pi*sensor.maxrange^2);
flt_param.N_max = length( this.postcard )-1;
flt_param.rho = this.numpartpersist;
flt_param.Lmax = this.maxnumpart;
cdn_pred = this.predcard;
this.proddenum = 1;
this.sumdenum = 0;

if isempty( this.predintensity )
    % nothing to update, return:
    if nargout == 0
        if ~isempty( inputname(1) )
            assignin('caller',inputname(1),this);
        else
            error('Could not overwrite the instance; make sure that the argument is not in an array!');
        end
    else
        varargout{1} = this;
        if nargout>=2
            varargout{2} = this.proddenum;
        end
    end
    return;
end

% Get the particles regarding the loc. dist. of the predicted intensity
w_pred = this.predintensity.s.particles.getweights...
    *this.predintensity.mu ;
p = this.predintensity.s.particles.getstates;

pt = p;
if nargin>=3
    pt([1,2],:) = p([1,2],:) - repmat( varargin{1}([1,2]),1, size(p,2) );
end

% Likelihood function matrix
% row m is for the m th observation, col n is for the n th particle
% M is the mask for FoV
[Gk, M, ppol] = sensor.likelihood( Z, pt );


this.sumdenum = 0;
this.proddenum = 1;
loglhood = 0;
%Update the weights
w_upd_comp = zeros(length(w_pred),Zk_len+1);
for i=1:Zk_len
    w_upd_comp(:,i) = P_D*Gk(i,:)'.*w_pred;
    denom = ( sum(w_upd_comp(:,i)) + this.nbintensity.mu*0 + meas.clutterpdf(i) );
    w_upd_comp(:,i) = w_upd_comp(:,i)/denom;
    this.sumdenum = this.sumdenum + (1/denom);
    this.proddenum = this.proddenum*denom;
    loglhood = loglhood + log(denom);
end  
    
w_upd_comp(:,Zk_len+1) =  w_pred * (1-P_D);

this.parlhood = exp( - P_D*this.mupred )*exp(loglhood);
this.parloglhood = loglhood -P_D*this.mupred;

if sensor.isdetonlynear
   if ~isempty(this.confintensity)
       if this.mupost ~= 0
           % Find the lenght of the previous posterior
          [Gkcint, Mcint, ppolcint] = sensor.likelihood( Z, this.confintensity.s.particles.states );
           
           ulabels = setdiff( unique( this.confintensity.s.particles.labels ), 0 );
           
           for i=1:length( ulabels )
              % Find the indices
               tind = find( this.confintensity.s.particles.labels == ulabels(i) );
               
               % min phi
               phimin = min( ppolcint( 1, tind ) );
               phimax = max( ppolcint( 1, tind ) );
               rmax   = max( ppolcint( 2, tind ) );
               
               cind = find( ppol(1,:)>=phimin & ppol(1,:)<=phimax );
               cind1 = find( ppol(2,cind) > rmax );
               
                ind = cind(cind1);
                if ~isempty(ind)
                    w_upd_comp( ind, Zk_len+1 ) = w_pred(ind);
                    w_upd_comp( ind, 1:Zk_len ) = 0;
                end               
           end
       end
   end
end

ind = find( M == 0 );
w_upd_comp( ind, Zk_len+1 ) = w_pred(ind);
w_upd_comp( ind, 1:Zk_len ) = 0;

%this.infobuffer = [ this.infobuffer, this.sumdenum ];

% MU:
% Here we sort the contribution of each measurement to each particle and
% achieve a clustering:
[maxCont, clusterIndx] = max( w_upd_comp(:,1:Zk_len+1)' );

% Label zero is for the clutter hypothesis
clusterIndx( find(clusterIndx==Zk_len+1 ) )=0;
    
% The weights are the sum of the contributions    
w_upd = sum(w_upd_comp,2)';
hat_N_soft = sum(w_upd);

if hat_N_soft> 0.05
    persupdate = this.predintensity.s.particles;
    persupdate = persupdate.sublabels( clusterIndx );
    persupdate = persupdate.subweights( w_upd/hat_N_soft );
    
   
    
    if this.regflag
        % persupdate = persupdate.updatekdebws('nonsparse','dims','all'); % Here, the BWs are found
        % NOTE: If the velocity components are generated by a mixture by the
        % adaptive new born target process, then the dims above should be
        % [1,2]'
       % if this.veldist.getnumcomp==1
            persupdate = persupdate.updatekdebwsblabh('nonsparse'); % Here, the BWs are found
       % else
       %     persupdate = persupdate.updatekdebws('nonsparse','dims',[1,2]'); % Here, the BWs are found
       % end
    end
   
    % Resample
    Lk= min(round(hat_N_soft*flt_param.rho),flt_param.Lmax);
    [persupdate, rind] = persupdate.resample(Lk); % Resample with the weights
    %persupdate = persupdate.mergeblab;
    
    if this.regflag
        %Regularise w/ bws
        %if isa( sensor, 'extsensor' )
        %    persupdate = persupdate.regwkde(100);
        %else
        % persupdate = persupdate.regwkde(10);
        regpersupdate = persupdate.regwkde(this.regvar);
        %end
        
        if this.mcmcmoveflag
            % MCMC move: Get the acceptance prob.s
            
            % Find the PseudoLikelihood for the regularised particles
            p = regpersupdate.getstates;
            % Likelihood function matrix
            % row m is for the m th observation, col n is for the n th particle
            Gk = sensor.likelihood( Z, p );
            
            trwres = this.predintensity.s.evaluate( persupdate.getstates )*this.predintensity.mu;
            trwreg = this.predintensity.s.evaluate( regpersupdate.getstates )*this.predintensity.mu;
            
            wres = compw( persupdate.getstates, Gk, P_D, meas.clutterpdf, trwres );
            wreg = compw( regpersupdate.getstates, Gk, P_D, meas.clutterpdf, trwreg );
            
            aprobs = min( ones(size(wres)), wreg./wres  );
            
            usamples = rand(size(aprobs));
            
            aind = find( usamples<= aprobs );
            
            persupdate.setel(regpersupdate.getel(aind), aind );
        else
           persupdate =  regpersupdate;
        end
        
        
    end
    
    persupdate = persupdate.inchist; % increase the history length by one
    
    % Updated number of targets
    this.mupost = hat_N_soft;
    cdn = poisspdf([0:length(this.postcard)-1], this.mupost)';
    
    
    this.postintensity = phd;
    this.postintensity.mu = this.mupost;
    
    this.postintensity.s.particles = persupdate;
    this.postintensity.s.kdes = [];
    this.postintensity.s.gmm = [];
    
    this.postcard  =cdn;
else
    this.postintensity = phd;
    this.postintensity = this.postintensity([]);
    
    this.mupost = 0;
    this.postcard = poisspdf([0:length(this.postcard)-1],  this.mupost)';
end



if nargout == 0
    if ~isempty( inputname(1) )
        assignin('caller',inputname(1),this);
    else
        error('Could not overwrite the instance; make sure that the argument is not in an array!');
    end
else
    varargout{1} = this;
    if nargout>=2
        varargout{2} = this.proddenum;
    end
    
end

end
function wu = compw( p, Gk, P_D, clutterpdf, trw )

trw = reshape( trw, length(trw), 1 );

[dp, np] = size(p);
Zk_len = size( Gk, 1 );

%Update the weights
wu = zeros( np, Zk_len+1);
for i=1:Zk_len
    wu(:,i) = P_D*Gk(i,:)'.*trw;
    denom = ( sum(wu(:,i)) + clutterpdf );
    wu(:,i) = wu(:,i)/denom;
end

wu(:,Zk_len+1) =  trw * (1-P_D);
%this.infobuffer = [ this.infobuffer, this.sumdenum ];

wu = sum(wu')';

end
