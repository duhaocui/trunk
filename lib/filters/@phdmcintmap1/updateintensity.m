function varargout = updateintensity( this, sensor, varargin )

Z = this.Z; % get the observation set

% lambda_c = sensor.clutter.getlambda;
flt_param.N_max = length( this.postcard )-1;
flt_param.rho = this.numpartpersist;
flt_param.Lmax = this.maxnumpart;
cdn_pred = this.predcard;
this.proddenum = 1;
this.sumdenum = 0;

if isempty( this.predintensity )
    % nothing to update, return:
    if nargout == 0
        if ~isempty( inputname(1) )
            assignin('caller',inputname(1),this);
        else
            error('Could not overwrite the instance; make sure that the argument is not in an array!');
        end
    else
        varargout{1} = this;
        if nargout>=2
            varargout{2} = this.proddenum;
        end
    end
    return;
end

% Get the particles regarding the loc. dist. of the predicted intensity
w_pred = this.predintensity.s.particles.getweights...
    *this.predintensity.mu ;
p = this.predintensity.s.particles.getstates;

pt = p;
if nargin>=3
    pt([1,2],:) = p([1,2],:) - repmat( varargin{1}([1,2]),1, size(p,2) );
end

% Likelihood function matrix
% row m is for the m th observation, col n is for the n th particle
% M is the mask for FoV
[Gk, M, ppol] = sensor.likelihood( Z, pt );

Omegas = exp( log(Gk(1,:)) -log(Gk(2,:)) ); % This is the \Omega(z_c(x)|x)
% % The weights are the sum of the contributions    
% w_upd = Omegas(:).*w_pred;
% hat_N_soft = sum(w_upd)/(sum(w_upd) + 1 - sum(w_pred) );

w_upd = Gk(1,:).*w_pred';

w_upd = w_upd/sum(w_upd);
w_upd = w_upd*(  sum( Omegas.*w_pred')/(1-sum(w_pred) + sum( Omegas.*w_pred') ) );

hat_N_soft = sum(w_upd);

if hat_N_soft> 0.001
    persupdate = this.predintensity.s.particles;
    persupdate = persupdate.subweights( w_upd );
 
    if this.regflag
        % persupdate = persupdate.updatekdebws('nonsparse','dims','all'); % Here, the BWs are found
        % NOTE: If the velocity components are generated by a mixture by the
        % adaptive new born target process, then the dims above should be
        % [1,2]'
       % if this.veldist.getnumcomp==1
       %    persupdate = persupdate.updatekdebwsblabh('nonsparse'); % Here, the BWs are found
       % else
            persupdate = persupdate.updatekdebws('nonsparse'); % Here, the BWs are found
       % end
    end
   
    % Resample
    Lk= min(round( max(1,hat_N_soft)*flt_param.rho),flt_param.Lmax);
    [persupdate, rind] = persupdate.resample(Lk); % Resample with the weights
    %persupdate = persupdate.mergeblab;
    
    if this.regflag
        %Regularise w/ bws
        %if isa( sensor, 'extsensor' )
        %    persupdate = persupdate.regwkde(100);
        %else
        % persupdate = persupdate.regwkde(10);
        regpersupdate = persupdate.regwkde(this.regvar,'dims',[1,2]);
        %end
        
        if this.mcmcmoveflag
            % MCMC move: Get the acceptance prob.s
            
            % Find the PseudoLikelihood for the regularised particles
            p = regpersupdate.getstates;
            % Likelihood function matrix
            % row m is for the m th observation, col n is for the n th particle
            Gk = sensor.likelihood( Z, p );
            
            trwres = this.predintensity.s.evaluate( persupdate.getstates )*this.predintensity.mu;
            trwreg = this.predintensity.s.evaluate( regpersupdate.getstates )*this.predintensity.mu;
            
            wres = compw( persupdate.getstates, Gk, P_D, meas.clutterpdf, trwres );
            wreg = compw( regpersupdate.getstates, Gk, P_D, meas.clutterpdf, trwreg );
            
            aprobs = min( ones(size(wres)), wreg./wres  );
            
            usamples = rand(size(aprobs));
            
            aind = find( usamples<= aprobs );
            
            persupdate.setel(regpersupdate.getel(aind), aind );
        else
           persupdate =  regpersupdate;
        end
        
        
    end
    
    persupdate = persupdate.inchist; % increase the history length by one
    
    % Updated number of targets
    this.mupost = hat_N_soft;
    cdn = poisspdf([0:length(this.postcard)-1], this.mupost)';
    
    
    this.postintensity = phd;
    this.postintensity.mu = this.mupost;
    
    this.postintensity.s.particles = persupdate;
    this.postintensity.s.kdes = [];
    this.postintensity.s.gmm = [];
    
    this.postcard  =cdn;
else
    this.postintensity = phd;
    this.postintensity = this.postintensity([]);
    
    this.mupost = 0;
    this.postcard = poisspdf([0:length(this.postcard)-1],  this.mupost)';
end



if nargout == 0
    if ~isempty( inputname(1) )
        assignin('caller',inputname(1),this);
    else
        error('Could not overwrite the instance; make sure that the argument is not in an array!');
    end
else
    varargout{1} = this;
    if nargout>=2
        varargout{2} = this.proddenum;
    end
    
end

end
function wu = compw( p, Gk, P_D, clutterpdf, trw )

trw = reshape( trw, length(trw), 1 );

[dp, np] = size(p);
Zk_len = size( Gk, 1 );

%Update the weights
wu = zeros( np, Zk_len+1);
for i=1:Zk_len
    wu(:,i) = P_D*Gk(i,:)'.*trw;
    denom = ( sum(wu(:,i)) + clutterpdf );
    wu(:,i) = wu(:,i)/denom;
end

wu(:,Zk_len+1) =  trw * (1-P_D);
%this.infobuffer = [ this.infobuffer, this.sumdenum ];

wu = sum(wu')';

end
